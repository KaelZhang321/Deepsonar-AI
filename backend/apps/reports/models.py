"""
Report model for storing AI-generated analysis results.

Each report captures the user's query and the final markdown output
generated by the CrewAI agent team.
"""
from django.conf import settings
from django.db import models
from django.utils import timezone


class Report(models.Model):
    """
    Model to store AI-generated business analysis reports.

    Attributes:
        user: The user who initiated the analysis (optional for anonymous use)
        query: The keyword/topic submitted by the user
        output: The final markdown report generated by the AI team
        status: Current status of the report generation
        created_at: When the report was initiated
        completed_at: When the report generation finished
    """

    class Status(models.TextChoices):
        """Report generation status choices."""
        PENDING = "pending", "Pending"
        IN_PROGRESS = "in_progress", "In Progress"
        COMPLETED = "completed", "Completed"
        FAILED = "failed", "Failed"

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="reports",
        help_text="User who requested the report"
    )
    query: models.CharField = models.CharField(
        max_length=500,
        help_text="The keyword or topic for analysis"
    )
    output: models.TextField = models.TextField(
        blank=True,
        help_text="The final markdown report output"
    )
    status: models.CharField = models.CharField(
        max_length=20,
        choices=Status.choices,
        default=Status.PENDING,
        help_text="Current status of report generation"
    )
    error_message: models.TextField = models.TextField(
        blank=True,
        help_text="Error message if report generation failed"
    )
    created_at: models.DateTimeField = models.DateTimeField(
        default=timezone.now,
        help_text="When the report was initiated"
    )
    completed_at: models.DateTimeField = models.DateTimeField(
        null=True,
        blank=True,
        help_text="When the report generation finished"
    )

    class Meta:
        db_table = "reports"
        verbose_name = "Report"
        verbose_name_plural = "Reports"
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Report: {self.query[:50]}... ({self.status})"

    def mark_completed(self, output: str) -> None:
        """Mark the report as completed with the given output."""
        self.output = output
        self.status = self.Status.COMPLETED
        self.completed_at = timezone.now()
        self.save()

    def mark_failed(self, error_message: str) -> None:
        """Mark the report as failed with an error message."""
        self.error_message = error_message
        self.status = self.Status.FAILED
        self.completed_at = timezone.now()
        self.save()


class ChatSession(models.Model):
    """
    Model to store chat sessions for conversation tracking.
    
    Each session represents a conversation thread between a user and the AI.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        null=True,
        blank=True,
        related_name="chat_sessions",
        help_text="User who owns this chat session"
    )
    title = models.CharField(
        max_length=200,
        default="New Chat",
        help_text="Title of the chat session"
    )
    created_at = models.DateTimeField(
        default=timezone.now,
        help_text="When the session was created"
    )

    class Meta:
        db_table = "chat_sessions"
        verbose_name = "Chat Session"
        verbose_name_plural = "Chat Sessions"
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Session: {self.title} ({self.created_at.strftime('%Y-%m-%d %H:%M')})"


class ChatMessage(models.Model):
    """
    Model to store individual chat messages within a session.
    """
    class Sender(models.TextChoices):
        USER = "user", "User"
        AI = "ai", "AI"

    session = models.ForeignKey(
        ChatSession,
        on_delete=models.CASCADE,
        related_name="messages",
        help_text="The session this message belongs to"
    )
    sender = models.CharField(
        max_length=10,
        choices=Sender.choices,
        help_text="Who sent the message"
    )
    content = models.TextField(
        help_text="The message content"
    )
    timestamp = models.DateTimeField(
        default=timezone.now,
        help_text="When the message was sent"
    )

    class Meta:
        db_table = "chat_messages"
        verbose_name = "Chat Message"
        verbose_name_plural = "Chat Messages"
        ordering = ["timestamp"]

    def __str__(self) -> str:
        return f"[{self.sender}] {self.content[:50]}..."


class SearchResult(models.Model):
    """
    Model to store web search results from Bocha AI.
    
    Each record captures a search query and its results for later reference.
    """
    keyword = models.CharField(
        max_length=500,
        db_index=True,
        help_text="搜索关键词"
    )
    report = models.ForeignKey(
        Report,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="search_results",
        help_text="关联的报告"
    )
    results_count = models.IntegerField(
        default=0,
        help_text="搜索结果数量"
    )
    results_json = models.JSONField(
        default=list,
        help_text="原始搜索结果 JSON"
    )
    formatted_results = models.TextField(
        blank=True,
        help_text="格式化的搜索结果文本"
    )
    search_source = models.CharField(
        max_length=50,
        default="bocha",
        help_text="搜索来源 (bocha, duckduckgo, etc.)"
    )
    created_at = models.DateTimeField(
        default=timezone.now,
        help_text="搜索时间"
    )

    class Meta:
        db_table = "search_results"
        verbose_name = "搜索结果"
        verbose_name_plural = "搜索结果"
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Search: {self.keyword[:50]} ({self.results_count} results)"


class CrawledContent(models.Model):
    """
    Model to store crawled web page content from Deep Read operations.
    
    Stores both raw content and summarized content for reference and caching.
    """
    class CrawlMethod(models.TextChoices):
        JINA = "jina", "Jina AI Reader"
        FIRECRAWL = "firecrawl", "Firecrawl"
        BEAUTIFULSOUP = "beautifulsoup", "BeautifulSoup"
        OTHER = "other", "Other"

    url = models.URLField(
        max_length=2000,
        db_index=True,
        help_text="爬取的 URL 地址"
    )
    report = models.ForeignKey(
        Report,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name="crawled_contents",
        help_text="关联的报告"
    )
    raw_content = models.TextField(
        blank=True,
        help_text="原始爬取内容 (Markdown)"
    )
    summary = models.TextField(
        blank=True,
        help_text="LLM 总结后的内容"
    )
    content_length = models.IntegerField(
        default=0,
        help_text="原始内容长度"
    )
    crawl_method = models.CharField(
        max_length=20,
        choices=CrawlMethod.choices,
        default=CrawlMethod.JINA,
        help_text="爬取方式"
    )
    success = models.BooleanField(
        default=True,
        help_text="爬取是否成功"
    )
    error_message = models.TextField(
        blank=True,
        help_text="错误信息（如果失败）"
    )
    created_at = models.DateTimeField(
        default=timezone.now,
        help_text="爬取时间"
    )

    class Meta:
        db_table = "crawled_contents"
        verbose_name = "爬取内容"
        verbose_name_plural = "爬取内容"
        ordering = ["-created_at"]

    def __str__(self) -> str:
        return f"Crawl: {self.url[:60]}... ({self.crawl_method})"
